// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:jsgen`.
// ignore_for_file: type=lint
/// Bindings to `headers/example.h`.
import 'dart:typed_data';
import 'dart:js_interop';
import 'dart:js_interop_unsafe';
import 'package:ffigen_js/ffigen_js.dart';

extension type GeneratedBindings(NativeLibrary _) implements JSObject {
  static GeneratedBindings get instance =>
      NativeLibrary.instance as GeneratedBindings;

  static void initBindings(String moduleName) {
    var lib = globalContext.getProperty(moduleName.toJS);
    if (lib == null) {
      throw Exception("Failed to find JS module ${moduleName}");
    }
    NativeLibrary.instance = lib as NativeLibrary;
  }

  external Pointer<Int32> _GLOBALINT;
  external void _write(
    Pointer<Int32> out,
  );
  external int _sum(
    int a,
    int b,
  );
  external INTTYPE _sum_with_typedef(
    INTTYPE a,
    INTTYPE b,
  );
  external int _subtract(
    Pointer<Int32> a,
    int b,
  );
  external Pointer<Int32> _multiply(
    int a,
    int b,
  );
  external Pointer<Float32> _divide(
    int a,
    int b,
  );
  external Pointer<Float64> _divide_precision(
    Pointer<Float32> a,
    Pointer<Float32> b,
  );
  external void _accept_fn_typedef_arg(
    FunctionTypedef arg,
  );
  external FunctionTypedef _return_fn_typedef();
  external void _uint8_tptr_(
    Pointer<Uint8> data,
  );
  external void _int8_tptr_method(
    Pointer<Int8> data,
  );
  external Pointer<Float64> _return_array();
  external Pointer<Void> _return_void_ptr();
  external void _accept_void_ptr(
    Pointer<Void> arg,
  );
  external int _struct_as_argument(
    Pointer<double3> vectorPtr,
  );
  external Pointer<MyStruct> _return_struct_ptr();
  external void _accept_struct_ptr(
    Pointer<MyStruct> arg,
  );
  external void _accept_struct_with_array(
    Pointer<StructWithArray> argPtr,
  );
  external void _accept_struct_with_struct(
    Pointer<StructWithStruct> argPtr,
  );
  external void _return_struct_with_array_by_value(
    Pointer<StructWithArray> StructWithArray_out,
  );
  external void _return_struct_by_value(
    Pointer<MyStruct> MyStruct_out,
    double a,
    Pointer<Char> b,
  );
  external Pointer<PointerClass<Int32>> _ptr_ptr(
    Pointer<PointerClass<Int32>> a,
    Pointer<PointerClass<Int32>> b,
  );
  external Pointer<Char> _copy_string(
    Pointer<Char> instr,
  );
  external void _accept_fn_pointer_with_no_args(
    Pointer<NativeFunction<void Function()>> callback,
  );
  external void _accept_fn_pointer_with_primitive_args(
    Pointer<NativeFunction<void Function(int arg)>> callback,
  );
  external void _accept_fn_pointer_with_ptr_args(
    Pointer<NativeFunction<void Function(PointerClass<MyStruct> arg)>> callback,
  );
  external void _accept_opaque_struct_ptr(
    Pointer<MyOpaqueStruct> ptr,
  );
  external int _returns_bool();
  external int _return_enum();
  external int _accept_enum(
    int val,
  );
  external int _return_enum_as_int();
  external JSBigInt _bigint_method(
    JSBigInt number,
  );
  external size_t _size_tmethod(
    size_t number,
  );
}

BigInt get GLOBALINT {
  final value = NativeLibrary.instance
      .getValueBigInt(GeneratedBindings.instance._GLOBALINT, "i64");
  return bigIntasUintN(64, value).toDart;
}

void write(
  Pointer<Int32> out,
) {
  final result = GeneratedBindings.instance._write(out);
  return result;
}

int sum(
  int a,
  int b,
) {
  final result = GeneratedBindings.instance._sum(a, b);
  return result;
}

DartINTTYPE sum_with_typedef(
  DartINTTYPE a,
  DartINTTYPE b,
) {
  final result = GeneratedBindings.instance._sum_with_typedef(a, b);
  return result;
}

int subtract(
  Pointer<Int32> a,
  int b,
) {
  final result = GeneratedBindings.instance._subtract(a, b);
  return result;
}

Pointer<Int32> multiply(
  int a,
  int b,
) {
  final result = GeneratedBindings.instance._multiply(a, b);
  return Pointer<Int32>(result);
}

Pointer<Float32> divide(
  int a,
  int b,
) {
  final result = GeneratedBindings.instance._divide(a, b);
  return Pointer<Float32>(result);
}

Pointer<Float64> divide_precision(
  Pointer<Float32> a,
  Pointer<Float32> b,
) {
  final result = GeneratedBindings.instance._divide_precision(a, b);
  return Pointer<Float64>(result);
}

void accept_fn_typedef_arg(
  DartFunctionTypedef arg,
) {
  final result = GeneratedBindings.instance._accept_fn_typedef_arg(
      arg as Pointer<NativeFunction<FunctionTypedefFunction>>);
  return result;
}

DartFunctionTypedef return_fn_typedef() {
  final result = GeneratedBindings.instance._return_fn_typedef();
  return DartFunctionTypedef(result);
}

void uint8_tptr_(
  Pointer<Uint8> data,
) {
  final result = GeneratedBindings.instance._uint8_tptr_(data);
  return result;
}

void int8_tptr_method(
  Pointer<Int8> data,
) {
  final result = GeneratedBindings.instance._int8_tptr_method(data);
  return result;
}

Pointer<Float64> return_array() {
  final result = GeneratedBindings.instance._return_array();
  return Pointer<Float64>(result);
}

Pointer<Void> return_void_ptr() {
  final result = GeneratedBindings.instance._return_void_ptr();
  return Pointer<Void>(result);
}

void accept_void_ptr(
  Pointer<Void> arg,
) {
  final result = GeneratedBindings.instance._accept_void_ptr(arg);
  return result;
}

int struct_as_argument(
  double3 vector,
) {
  final vectorPtr = vector.address;
  final result =
      GeneratedBindings.instance._struct_as_argument(vectorPtr.cast());
  return result;
}

Pointer<MyStruct> return_struct_ptr() {
  final result = GeneratedBindings.instance._return_struct_ptr();
  return Pointer<MyStruct>(result);
}

void accept_struct_ptr(
  Pointer<MyStruct> arg,
) {
  final result = GeneratedBindings.instance._accept_struct_ptr(arg.cast());
  return result;
}

void accept_struct_with_array(
  StructWithArray arg,
) {
  final argPtr = arg.address;
  final result =
      GeneratedBindings.instance._accept_struct_with_array(argPtr.cast());
  return result;
}

void accept_struct_with_struct(
  StructWithStruct arg,
) {
  final argPtr = arg.address;
  final result =
      GeneratedBindings.instance._accept_struct_with_struct(argPtr.cast());
  return result;
}

StructWithArray return_struct_with_array_by_value() {
  final StructWithArray_out = StructWithArray.stackAlloc();
  final result = GeneratedBindings.instance
      ._return_struct_with_array_by_value(StructWithArray_out.cast());
  return StructWithArray_out.toDart();
}

MyStruct return_struct_by_value(
  double a,
  Pointer<Char> b,
) {
  final MyStruct_out = MyStruct.stackAlloc();
  final result = GeneratedBindings.instance
      ._return_struct_by_value(MyStruct_out.cast(), a, b);
  return MyStruct_out.toDart();
}

Pointer<PointerClass<Int32>> ptr_ptr(
  Pointer<PointerClass<Int32>> a,
  Pointer<PointerClass<Int32>> b,
) {
  final result = GeneratedBindings.instance._ptr_ptr(a, b);
  return Pointer<PointerClass<Int32>>(result);
}

Pointer<Char> copy_string(
  Pointer<Char> instr,
) {
  final result = GeneratedBindings.instance._copy_string(instr);
  return Pointer<Char>(result);
}

void accept_fn_pointer_with_no_args(
  Pointer<NativeFunction<void Function()>> callback,
) {
  final result = GeneratedBindings.instance
      ._accept_fn_pointer_with_no_args(callback.cast());
  return result;
}

void accept_fn_pointer_with_primitive_args(
  Pointer<NativeFunction<void Function(int arg)>> callback,
) {
  final result = GeneratedBindings.instance
      ._accept_fn_pointer_with_primitive_args(callback.cast());
  return result;
}

void accept_fn_pointer_with_ptr_args(
  Pointer<NativeFunction<void Function(Pointer<MyStruct> arg)>> callback,
) {
  final result = GeneratedBindings.instance
      ._accept_fn_pointer_with_ptr_args(callback.cast());
  return result;
}

void accept_opaque_struct_ptr(
  Pointer<MyOpaqueStruct> ptr,
) {
  final result =
      GeneratedBindings.instance._accept_opaque_struct_ptr(ptr.cast());
  return result;
}

bool returns_bool() {
  final result = GeneratedBindings.instance._returns_bool();
  return result == 1;
}

MyEnum return_enum() {
  final result = GeneratedBindings.instance._return_enum();
  return MyEnum.fromValue(result);
}

int accept_enum(
  MyEnum val,
) {
  final result = GeneratedBindings.instance._accept_enum(val.value);
  return result;
}

int return_enum_as_int() {
  final result = GeneratedBindings.instance._return_enum_as_int();
  return result;
}

BigInt bigint_method(
  BigInt number,
) {
  final result = GeneratedBindings.instance._bigint_method(number.toJSBigInt);
  return bigIntasUintN(64, result).toDart;
}

Dart__darwin_size_t size_tmethod(
  Dart__darwin_size_t number,
) {
  final result = GeneratedBindings.instance._size_tmethod(number);
  return result;
}

typedef INTTYPE = int;
typedef DartINTTYPE = int;
typedef FunctionTypedef = Pointer<NativeFunction<FunctionTypedefFunction>>;
typedef DartFunctionTypedef = Pointer<NativeFunction<FunctionTypedefFunction>>;
typedef FunctionTypedefFunction = void Function(Pointer<Void> owner);
typedef DartFunctionTypedefFunction = void Function(Pointer<Void> owner);

extension double3Ext on Pointer<double3> {
  double3 toDart() {
    return double3(this);
  }
}

final class double3 extends Struct {
  double get x {
    final addr = this.address + 0;
    final value = NativeLibrary.instance.getValue(addr, 'double').toDartDouble;
    return value;
  }

  set x(double val) {
    NativeLibrary.instance.setValue(this.address + 0, val.toJS, 'double');
  }

  double get y {
    final addr = this.address + 8;
    final value = NativeLibrary.instance.getValue(addr, 'double').toDartDouble;
    return value;
  }

  set y(double val) {
    NativeLibrary.instance.setValue(this.address + 8, val.toJS, 'double');
  }

  double get z {
    final addr = this.address + 16;
    final value = NativeLibrary.instance.getValue(addr, 'double').toDartDouble;
    return value;
  }

  set z(double val) {
    NativeLibrary.instance.setValue(this.address + 16, val.toJS, 'double');
  }

  double3(super.address);

  static Pointer<double3> stackAlloc() {
    return Pointer<double3>(NativeLibrary.instance.stackAlloc<double3>(24));
  }
}

extension MyStructExt on Pointer<MyStruct> {
  MyStruct toDart() {
    return MyStruct(this);
  }
}

final class MyStruct extends Struct {
  double get a {
    final addr = this.address + 0;
    final value = NativeLibrary.instance.getValue(addr, 'float').toDartDouble;
    return value;
  }

  set a(double val) {
    NativeLibrary.instance.setValue(this.address + 0, val.toJS, 'float');
  }

  Pointer<Char> get b {
    final addr = this.address + 4;
    final value = NativeLibrary.instance.getValue(addr, '*');
    return Pointer<Char>(value.toDartInt);
  }

  set b(Pointer<Char> val) {
    NativeLibrary.instance.setValue(this.address + 4, val.toJS, '*');
  }

  int get c {
    final addr = this.address + 8;
    final value = NativeLibrary.instance.getValue(addr, 'i32').toDartInt;
    return value;
  }

  set c(int val) {
    NativeLibrary.instance.setValue(this.address + 8, val.toJS, 'i32');
  }

  MyStruct(super.address);

  static Pointer<MyStruct> stackAlloc() {
    return Pointer<MyStruct>(NativeLibrary.instance.stackAlloc<MyStruct>(12));
  }
}

extension StructWithArrayExt on Pointer<StructWithArray> {
  StructWithArray toDart() {
    return StructWithArray(this);
  }
}

final class StructWithArray extends Struct {
  Array<Float64> get array1 {
    final addr = this.address + 0;
    final value = NativeLibrary.instance.getValue(addr, '*');
    return Array<Float64>(
        (numElements: 2, addr: Pointer<Float64>(this.address + 0)));
  }

  set array1(Array<Float64> val) {
    NativeLibrary.instance
        .setValue(this.address + 0, val.internal.addr.addr.toJS, '*');
  }

  Array<Float64> get array2 {
    final addr = this.address + 16;
    final value = NativeLibrary.instance.getValue(addr, '*');
    return Array<Float64>(
        (numElements: 3, addr: Pointer<Float64>(this.address + 16)));
  }

  set array2(Array<Float64> val) {
    NativeLibrary.instance
        .setValue(this.address + 16, val.internal.addr.addr.toJS, '*');
  }

  StructWithArray(super.address);

  static Pointer<StructWithArray> stackAlloc() {
    return Pointer<StructWithArray>(
        NativeLibrary.instance.stackAlloc<StructWithArray>(40));
  }
}

extension StructWithStructExt on Pointer<StructWithStruct> {
  StructWithStruct toDart() {
    return StructWithStruct(this);
  }
}

final class StructWithStruct extends Struct {
  StructWithArray get struct1 {
    final addr = this.address + 0;
    final value = NativeLibrary.instance.getValue(addr, '*');
    return StructWithArray(Pointer<StructWithArray>(addr));
  }

  set struct1(StructWithArray val) {
    NativeLibrary.instance.setValue(this.address + 0, val.address.toJS, '*');
  }

  StructWithArray get struct2 {
    final addr = this.address + 40;
    final value = NativeLibrary.instance.getValue(addr, '*');
    return StructWithArray(Pointer<StructWithArray>(addr));
  }

  set struct2(StructWithArray val) {
    NativeLibrary.instance.setValue(this.address + 40, val.address.toJS, '*');
  }

  StructWithStruct(super.address);

  static Pointer<StructWithStruct> stackAlloc() {
    return Pointer<StructWithStruct>(
        NativeLibrary.instance.stackAlloc<StructWithStruct>(80));
  }
}

extension MyOpaqueStructExt on Pointer<MyOpaqueStruct> {
  MyOpaqueStruct toDart() {
    return MyOpaqueStruct(this);
  }
}

final class MyOpaqueStruct extends Struct {
  MyOpaqueStruct(super.address);

  static Pointer<MyOpaqueStruct> stackAlloc() {
    return Pointer<MyOpaqueStruct>(
        NativeLibrary.instance.stackAlloc<MyOpaqueStruct>(0));
  }
}

enum MyEnum {
  ENUM_VAL1(0),
  ENUM_VAL2(1);

  final int value;
  const MyEnum(this.value);

  static MyEnum fromValue(int value) => switch (value) {
        0 => ENUM_VAL1,
        1 => ENUM_VAL2,
        _ => throw ArgumentError("Unknown value for MyEnum: $value"),
      };
}

sealed class MyEnumAsInt {
  static const ENUM_AS_INT_VAL1 = 0;
  static const ENUM_AS_INT_VAL2 = 1;
}

typedef size_t = __darwin_size_t;
typedef __darwin_size_t = int;
typedef Dart__darwin_size_t = int;

const int __has_safe_buffers = 0;

const int __DARWIN_ONLY_64_BIT_INO_T = 1;

const int __DARWIN_ONLY_UNIX_CONFORMANCE = 1;

const int __DARWIN_ONLY_VERS_1050 = 1;

const int __DARWIN_UNIX03 = 1;

const int __DARWIN_64_BIT_INO_T = 1;

const int __DARWIN_VERS_1050 = 1;

const int __DARWIN_NON_CANCELABLE = 0;

const String __DARWIN_SUF_EXTSN = '\$DARWIN_EXTSN';

const int __DARWIN_C_ANSI = 4096;

const int __DARWIN_C_FULL = 900000;

const int __DARWIN_C_LEVEL = 900000;

const int __STDC_WANT_LIB_EXT1__ = 1;

const int __DARWIN_NO_LONG_LONG = 0;

const int _DARWIN_FEATURE_64_BIT_INODE = 1;

const int _DARWIN_FEATURE_ONLY_64_BIT_INODE = 1;

const int _DARWIN_FEATURE_ONLY_VERS_1050 = 1;

const int _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE = 1;

const int _DARWIN_FEATURE_UNIX_CONFORMANCE = 3;

const int __has_ptrcheck = 0;

const int __has_bounds_safety_attributes = 0;

const int __DARWIN_NULL = 0;

const int __PTHREAD_SIZE__ = 8176;

const int __PTHREAD_ATTR_SIZE__ = 56;

const int __PTHREAD_MUTEXATTR_SIZE__ = 8;

const int __PTHREAD_MUTEX_SIZE__ = 56;

const int __PTHREAD_CONDATTR_SIZE__ = 8;

const int __PTHREAD_COND_SIZE__ = 40;

const int __PTHREAD_ONCE_SIZE__ = 8;

const int __PTHREAD_RWLOCK_SIZE__ = 192;

const int __PTHREAD_RWLOCKATTR_SIZE__ = 16;

const int __DARWIN_WCHAR_MAX = 2147483647;

const int __DARWIN_WCHAR_MIN = -2147483648;

const int __DARWIN_WEOF = -1;

const int _FORTIFY_SOURCE = 2;

const int NULL = 0;

const int USER_ADDR_NULL = 0;

const int __WORDSIZE = 64;

const int INT8_MAX = 127;

const int INT16_MAX = 32767;

const int INT32_MAX = 2147483647;

const int INT64_MAX = 9223372036854775807;

const int INT8_MIN = -128;

const int INT16_MIN = -32768;

const int INT32_MIN = -2147483648;

const int INT64_MIN = -9223372036854775808;

const int UINT8_MAX = 255;

const int UINT16_MAX = 65535;

const int UINT32_MAX = 4294967295;

const int UINT64_MAX = -1;

const int INT_LEAST8_MIN = -128;

const int INT_LEAST16_MIN = -32768;

const int INT_LEAST32_MIN = -2147483648;

const int INT_LEAST64_MIN = -9223372036854775808;

const int INT_LEAST8_MAX = 127;

const int INT_LEAST16_MAX = 32767;

const int INT_LEAST32_MAX = 2147483647;

const int INT_LEAST64_MAX = 9223372036854775807;

const int UINT_LEAST8_MAX = 255;

const int UINT_LEAST16_MAX = 65535;

const int UINT_LEAST32_MAX = 4294967295;

const int UINT_LEAST64_MAX = -1;

const int INT_FAST8_MIN = -128;

const int INT_FAST16_MIN = -32768;

const int INT_FAST32_MIN = -2147483648;

const int INT_FAST64_MIN = -9223372036854775808;

const int INT_FAST8_MAX = 127;

const int INT_FAST16_MAX = 32767;

const int INT_FAST32_MAX = 2147483647;

const int INT_FAST64_MAX = 9223372036854775807;

const int UINT_FAST8_MAX = 255;

const int UINT_FAST16_MAX = 65535;

const int UINT_FAST32_MAX = 4294967295;

const int UINT_FAST64_MAX = -1;

const int INTPTR_MAX = 9223372036854775807;

const int INTPTR_MIN = -9223372036854775808;

const int UINTPTR_MAX = -1;

const int INTMAX_MAX = 9223372036854775807;

const int UINTMAX_MAX = -1;

const int INTMAX_MIN = -9223372036854775808;

const int PTRDIFF_MIN = -9223372036854775808;

const int PTRDIFF_MAX = 9223372036854775807;

const int SIZE_MAX = -1;

const int RSIZE_MAX = 9223372036854775807;

const int WCHAR_MAX = 2147483647;

const int WCHAR_MIN = -2147483648;

const int WINT_MIN = -2147483648;

const int WINT_MAX = 2147483647;

const int SIG_ATOMIC_MIN = -2147483648;

const int SIG_ATOMIC_MAX = 2147483647;

const int __bool_true_false_are_defined = 1;

extension StructAllocator on Struct {
  static T create<T>() {
    switch (T) {
      case double3:
        final ptr = double3.stackAlloc();
        return ptr.toDart() as T;
      case MyStruct:
        final ptr = MyStruct.stackAlloc();
        return ptr.toDart() as T;
      case StructWithArray:
        final ptr = StructWithArray.stackAlloc();
        return ptr.toDart() as T;
      case StructWithStruct:
        final ptr = StructWithStruct.stackAlloc();
        return ptr.toDart() as T;
      case MyOpaqueStruct:
        final ptr = MyOpaqueStruct.stackAlloc();
        return ptr.toDart() as T;
    }
    throw Exception("Unsupported type $T");
  }
}

extension NativeFunctionPointer0<T extends NativeType> on void Function() {
  Pointer<NativeFunction<void Function()>> addFunction() {
    return Pointer<NativeFunction<void Function()>>(
            NativeLibrary.instance.addFunction<void Function()>(this.toJS, 'v'))
        .cast();
  }
}

extension NativeFunctionPointer1<T extends NativeType> on void Function(
    int arg) {
  Pointer<NativeFunction<void Function(int arg)>> addFunction() {
    return Pointer<NativeFunction<void Function(int arg)>>(NativeLibrary
            .instance
            .addFunction<void Function(int arg)>(this.toJS, 'vi'))
        .cast();
  }
}

extension NativeFunctionPointer2<T extends NativeType> on void Function(
    Pointer<T>) {
  Pointer<NativeFunction<void Function(Pointer<MyStruct> arg)>> addFunction() {
    return Pointer<NativeFunction<void Function(Pointer<MyStruct> arg)>>(
            NativeLibrary.instance
                .addFunction<void Function(Pointer<MyStruct> arg)>(
                    this.toJS, 'vp'))
        .cast();
  }
}
